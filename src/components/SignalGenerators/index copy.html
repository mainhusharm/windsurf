<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMC Pro Elite - Real-Time Trading Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0F0C29 0%, #302B63 50%, #24243E 100%);
            color: #E0E0E0;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }
        
        .header p {
            font-size: 1rem;
            color: #9e9e9e;
        }

        .market-toggle {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .market-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #E0E0E0;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .market-btn.active {
            background: linear-gradient(45deg, #e94057, #f27121);
            border-color: #f27121;
            color: white;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff4757;
        }

        .status-dot.active {
            background-color: #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-panel h3 {
            margin-bottom: 15px;
            color: #00d2ff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #BDBDBD;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .select-all-option {
            background: #e94057;
            color: white;
            font-weight: bold;
        }

        button {
            background: linear-gradient(45deg, #8e2de2, #4a00e0);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(142, 45, 226, 0.4);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.1);
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .refresh-btn {
            background: linear-gradient(45deg, #f27121, #e94057);
        }

        .stop-btn {
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
        }

        .signals-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .signal-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #00d2ff;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .signal-card:hover {
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.1);
        }

        .signal-card.bearish {
            border-left-color: #ff416c;
        }

        .signal-card.target_hit {
            border-left-color: #00e676;
            background: rgba(0, 230, 118, 0.1);
        }

        .signal-card.sl_hit {
            border-left-color: #ff1744;
            background: rgba(255, 23, 68, 0.1);
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .signal-type {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .signal-type.bullish {
            color: #00d2ff;
        }

        .signal-type.bearish {
            color: #ff416c;
        }

        .confidence {
            background: linear-gradient(45deg, #f27121, #e94057);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .signal-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .detail-item {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .detail-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 2px;
        }

        .detail-value {
            font-weight: bold;
        }

        .analysis {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .signal-status {
            position: absolute;
            top: 15px;
            right: 15px;
            font-weight: bold;
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .signal-card.target_hit .signal-status {
            background: rgba(0, 230, 118, 0.2);
            color: #00e676;
        }

        .signal-card.sl_hit .signal-status {
            background: rgba(255, 23, 68, 0.2);
            color: #ff1744;
        }

        .logs {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .log-time {
            color: #00d2ff;
        }

        .error {
            color: #ff416c;
        }

        .success {
            color: #00ff88;
        }

        .no-signals {
            text-align: center;
            padding: 40px;
            opacity: 0.7;
        }

        .market-data {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .data-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .data-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .data-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .positive {
            color: #00ff88;
        }

        .negative {
            color: #ff416c;
        }

        .signal-time {
            font-size: 0.8rem;
            opacity: 0.7;
            position: absolute;
            bottom: 5px;
            right: 10px;
        }

        .exit-signal {
            border-left-color: #ffc107;
        }

        .exit-critical {
            border-left-color: #dc3545;
        }

        .exit-factors-section {
            margin-top: 10px;
        }

        .exit-factors-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .exit-factors-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .exit-factor-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .exit-btn.critical {
            background: linear-gradient(45deg, #dc3545, #b22222);
        }

        .exit-btn.warning {
            background: linear-gradient(45deg, #ffc107, #ff8f00);
        }

        .monitor-btn {
            background: linear-gradient(45deg, #2196f3, #0d47a1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ SMC Pro Elite - Real-Time Trading Bot</h1>
            <p>Smart Money Concepts - Professional Forex & Crypto Analysis</p>
        </div>

        <div class="market-toggle">
            <button class="market-btn active" onclick="switchMarket('crypto')">
                ü™ô Crypto Markets
            </button>
            <button class="market-btn" onclick="switchMarket('forex')">
                üí± Forex Markets
            </button>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Ready to Connect</span>
            </div>
            <div id="winRate">Win Rate: --%</div>
            <div id="lastUpdate">Last Update: Never</div>
        </div>

        <div class="controls">
            <div class="control-panel">
                <h3>‚öôÔ∏è Trading Settings</h3>
                <div class="input-group">
                    <label>Symbol</label>
                    <select id="symbol">
                        <option value="">Select Symbol</option>
                        <option value="ALL" class="select-all-option">üìä ALL SYMBOLS</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Timeframe</label>
                    <select id="timeframe">
                        <option value="">Select Timeframe</option>
                        <option value="ALL" class="select-all-option">‚è∞ ALL TIMEFRAMES</option>
                        <option value="1m">1 Minute</option>
                        <option value="3m">3 Minutes</option>
                        <option value="5m">5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="30m">30 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                        <option value="1d">1 Day</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Risk:Reward Ratio</label>
                    <input type="number" id="riskReward" placeholder="Enter R:R (e.g., 2.0)" step="0.1" min="1" max="10" value="2.0">
                </div>
                <button onclick="startBot()">Start Real-Time Analysis</button>
                <button onclick="stopBot()" disabled class="stop-btn">Stop Bot</button>
                <button onclick="refreshSystem()" class="refresh-btn">üîÑ Refresh System</button>
            </div>

            <div class="control-panel">
                <h3>üìä Live Market Data</h3>
                <div class="market-data">
                    <div class="data-item">
                        <div class="data-label">Active Pairs</div>
                        <div class="data-value" id="activePairs">0</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Signals Today</div>
                        <div class="data-value" id="signalsToday">0</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Active Timeframes</div>
                        <div class="data-value" id="activeTimeframes">0</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">System Status</div>
                        <div class="data-value" id="systemStatus">Ready</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="signals-panel">
            <h3>üéØ Live Trading Signals</h3>
            <div id="signalsContainer">
                <div class="no-signals">
                    <p>Configure settings and start the bot to receive real-time signals</p>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <h3>üìù System Logs</h3>
            <div class="logs" id="logs">
                <div class="log-entry">
                    <span class="log-time">[Ready]</span> SMC Pro Elite Bot initialized - Configure settings to start
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const winRateEl = document.getElementById('winRate');
        const lastUpdateEl = document.getElementById('lastUpdate');
        const symbolSelect = document.getElementById('symbol');
        const timeframeSelect = document.getElementById('timeframe');
        const riskRewardInput = document.getElementById('riskReward');
        const startBtn = document.querySelector('button[onclick="startBot()"]');
        const stopBtn = document.querySelector('button[onclick="stopBot()"]');
        const signalsContainer = document.getElementById('signalsContainer');
        const logsContainer = document.getElementById('logs');
        const activePairsEl = document.getElementById('activePairs');
        const signalsTodayEl = document.getElementById('signalsToday');
        const activeTimeframesEl = document.getElementById('activeTimeframes');
        const systemStatusEl = document.getElementById('systemStatus');
        const marketBtns = document.querySelectorAll('.market-btn');

        // --- Global State ---
        let botRunning = false;
        let currentMarket = 'crypto';
        let activeConnections = [];
        let signalHistory = [];
        let lastData = {};
        window.riskRewardRatio = 2.0;

        // --- Market Configurations ---
        const markets = {
            crypto: {
                symbols: [
                    'BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'DOTUSDT',
                    'DOGEUSDT', 'AVAXUSDT', 'LINKUSDT', 'LTCUSDT', 'XLMUSDT', 'FILUSDT', 'AAVEUSDT'
                ],
                apiKey: 'Og5MH2GE4oSsf0EhsukjG0ftrFSfv78C7oln2yxL3Mk1HBGruf8xkTCXBND9z6au'
            },
            forex: {
                symbols: [
                    'XAUUSD', 'XAGUSD', 'USOIL', 'US30', 'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF',
                    'AUDUSD', 'USDCAD', 'NZDUSD', 'EURJPY', 'GBPJPY', 'EURGBP', 'AUDJPY',
                    'CADJPY', 'CHFJPY', 'EURAUD', 'EURCHF', 'EURCAD', 'GBPAUD', 'GBPCAD',
                    'GBPCHF', 'AUDCAD', 'AUDCHF', 'AUDNZD', 'CADCHF', 'NZDCAD', 'NZDCHF', 'NZDJPY'
                ]
            }
        };

        // =================================================================
        // ADVANCED SMC TRADING LOGIC - BASED ON YOUR PINE SCRIPT INDICATOR
        // Directly implements the logic from your TradingView indicator
        // =================================================================

        class ProfessionalSMCEngine {
            constructor() {
                this.priceHistory = new Map();
                this.swingHighs = new Map();
                this.swingLows = new Map();
                this.internalHighs = new Map();
                this.internalLows = new Map();
                this.swingTrend = new Map();
                this.internalTrend = new Map();
                this.orderBlocks = new Map();
                this.fairValueGaps = new Map();
                this.equalHighs = new Map();
                this.equalLows = new Map();
                this.lastSignalTime = new Map();
                
                // NEW: Position tracking and exit monitoring
                this.activePositions = new Map(); // Track open positions
                this.positionHistory = new Map();  // Track position performance
                this.marketConditions = new Map();  // Track market state changes
                this.exitSignals = new Map();      // Track exit signals
                
                // Confidence scoring based on your indicator's confirmations
                this.confirmationScores = {
                    // PRIMARY STRUCTURE CONFIRMATIONS (High Impact)
                    'swingBullishBOS': 30,
                    'swingBearishBOS': 30,
                    'swingBullishCHoCH': 25,
                    'swingBearishCHoCH': 25,
                    'internalBullishBOS': 20,
                    'internalBearishBOS': 20,
                    'internalBullishCHoCH': 18,
                    'internalBearishCHoCH': 18,
                    
                    // ORDER BLOCK CONFIRMATIONS
                    'swingOrderBlockRespect': 22,
                    'internalOrderBlockRespect': 18,
                    
                    // FAIR VALUE GAP CONFIRMATIONS
                    'bullishFairValueGap': 15,
                    'bearishFairValueGap': 15,
                    
                    // EQUAL HIGHS/LOWS
                    'equalHighsBreak': 12,
                    'equalLowsBreak': 12,
                    
                    // PREMIUM/DISCOUNT ZONES
                    'premiumZoneEntry': 10,
                    'discountZoneEntry': 10,
                    'equilibriumZone': 8,
                    
                    // ADDITIONAL CONFLUENCES
                    'multiTimeframeAlignment': 8,
                    'volumeConfirmation': 6,
                    'strongWeakHighLow': 5,
                    'atrVolatilityFilter': 4
                };
                
                // Exit signal criteria
                this.exitCriteria = {
                    // Structure invalidation (High priority exits)
                    'oppositeStructureBreak': 40,      // Opposite BOS/CHoCH formed
                    'swingFailure': 35,                // Failed to hold key swing level
                    'trendReversal': 30,               // Clear trend reversal pattern
                    
                    // Market condition changes (Medium priority)
                    'momentumDivergence': 25,          // Momentum divergence detected
                    'volumeWeakness': 20,              // Volume declining significantly
                    'orderBlockBroken': 18,            // Supporting order block broken
                    'fvgFilled': 15,                   // Fair value gap filled against position
                    
                    // Risk management (Lower priority but important)
                    'volatilitySpike': 12,             // Unusual volatility increase
                    'sessionChange': 10,               // Moving into low-quality session
                    'timeBasedExit': 8,                // Position held too long
                    'partialProfitZone': 5             // Reached partial profit zone
                };
                
                // Minimum requirements for signal generation
                this.signalRequirements = {
                    minPrimaryConfirmations: 1,  // Must have BOS/CHoCH
                    minTotalConfirmations: 4,    // Minimum 4 confirmations
                    minConfidenceScore: 60,      // Minimum 60% confidence
                    minHistoryBars: 25,          // Need enough price history
                    cooldownPeriod: 300000       // 5 minutes between signals
                };
                
                // Exit signal requirements
                this.exitRequirements = {
                    minExitScore: 30,            // Minimum score to suggest exit
                    criticalExitScore: 50,       // Score for immediate exit suggestion
                    maxPositionAge: 14400000     // 4 hours max position age
                };
            }

            // =================================================================
            // MAIN ANALYSIS FUNCTION - Enhanced with position monitoring
            // =================================================================
            analyzeSMCPatterns(symbol, currentPriceData) {
                try {
                    const currentPrice = parseFloat(currentPriceData.price);
                    const timestamp = Date.now();
                    
                    // Initialize data structures
                    this.initializeSymbolData(symbol, currentPrice, timestamp);
                    
                    // Check for position exit signals FIRST
                    const exitAnalysis = this.analyzePositionExits(symbol, currentPrice, timestamp);
                    if (exitAnalysis) {
                        return exitAnalysis; // Return exit signal if needed
                    }
                    
                    // Check cooldown period for new entries
                    if (!this.canGenerateSignal(symbol, timestamp)) {
                        return null;
                    }
                    
                    // Get price history and perform structure analysis
                    const priceHistory = this.priceHistory.get(symbol);
                    if (priceHistory.length < this.signalRequirements.minHistoryBars) {
                        return null;
                    }
                    
                    // Perform comprehensive SMC analysis based on your indicator
                    const analysis = this.performStructureAnalysis(symbol, priceHistory, currentPrice);
                    
                    // Generate signal if requirements are met
                    if (this.validateSignalQuality(analysis)) {
                        this.lastSignalTime.set(symbol, timestamp);
                        const signal = this.createTradingSignal(symbol, analysis, currentPrice);
                        
                        // Track the new position
                        this.trackNewPosition(symbol, signal, timestamp);
                        
                        return signal;
                    }
                    
                    return null;
                    
                } catch (error) {
                    console.error(`SMC Analysis Error for ${symbol}:`, error);
                    return null;
                }
            }

            // =================================================================
            // POSITION EXIT ANALYSIS - New intelligent exit system
            // =================================================================
            analyzePositionExits(symbol, currentPrice, timestamp) {
                const activePosition = this.activePositions.get(symbol);
                if (!activePosition) return null; // No position to monitor
                
                const exitFactors = [];
                let exitScore = 0;
                
                // 1. CHECK FOR OPPOSITE STRUCTURE BREAKS
                const currentTrend = this.swingTrend.get(symbol) || { bias: 0 };
                const positionDirection = activePosition.signalType;
                
                if ((positionDirection === 'BUY' && currentTrend.bias === -1) ||
                    (positionDirection === 'SELL' && currentTrend.bias === 1)) {
                    exitFactors.push('oppositeStructureBreak');
                    exitScore += this.exitCriteria.oppositeStructureBreak;
                }
                
                // 2. CHECK FOR SWING LEVEL FAILURES
                const swingFailure = this.detectSwingFailure(symbol, currentPrice, activePosition);
                if (swingFailure.detected) {
                    exitFactors.push('swingFailure');
                    exitScore += this.exitCriteria.swingFailure;
                }
                
                // 3. CHECK FOR TREND REVERSAL PATTERNS
                const trendReversal = this.detectTrendReversal(symbol, currentPrice);
                if (trendReversal) {
                    exitFactors.push('trendReversal');
                    exitScore += this.exitCriteria.trendReversal;
                }
                
                // 4. CHECK FOR MOMENTUM DIVERGENCE
                const momentumDiv = this.detectMomentumDivergence(symbol, currentPrice, activePosition);
                if (momentumDiv) {
                    exitFactors.push('momentumDivergence');
                    exitScore += this.exitCriteria.momentumDivergence;
                }
                
                // 5. CHECK FOR VOLUME WEAKNESS
                const volumeWeakness = this.detectVolumeWeakness(symbol);
                if (volumeWeakness) {
                    exitFactors.push('volumeWeakness');
                    exitScore += this.exitCriteria.volumeWeakness;
                }
                
                // 6. CHECK FOR ORDER BLOCK BREAKS
                const orderBlockBroken = this.checkOrderBlockBreaks(symbol, currentPrice, activePosition);
                if (orderBlockBroken) {
                    exitFactors.push('orderBlockBroken');
                    exitScore += this.exitCriteria.orderBlockBroken;
                }
                
                // 7. CHECK FOR FVG FILLS AGAINST POSITION
                const fvgFilled = this.checkFVGFills(symbol, currentPrice, activePosition);
                if (fvgFilled) {
                    exitFactors.push('fvgFilled');
                    exitScore += this.exitCriteria.fvgFilled;
                }
                
                // 8. CHECK FOR VOLATILITY SPIKES
                const volSpike = this.detectVolatilitySpike(symbol);
                if (volSpike) {
                    exitFactors.push('volatilitySpike');
                    exitScore += this.exitCriteria.volatilitySpike;
                }
                
                // 9. CHECK FOR SESSION QUALITY CHANGES
                const sessionChange = this.checkSessionQuality(timestamp);
                if (sessionChange.lowQuality) {
                    exitFactors.push('sessionChange');
                    exitScore += this.exitCriteria.sessionChange;
                }
                
                // 10. CHECK FOR TIME-BASED EXITS
                const positionAge = timestamp - activePosition.entryTime;
                if (positionAge > this.exitRequirements.maxPositionAge) {
                    exitFactors.push('timeBasedExit');
                    exitScore += this.exitCriteria.timeBasedExit;
                }
                
                // 11. CHECK FOR PARTIAL PROFIT ZONES
                const partialProfit = this.checkPartialProfitZone(currentPrice, activePosition);
                if (partialProfit.inZone) {
                    exitFactors.push('partialProfitZone');
                    exitScore += this.exitCriteria.partialProfitZone;
                }
                
                // EVALUATE EXIT NECESSITY
                if (exitScore >= this.exitRequirements.criticalExitScore) {
                    return this.createExitSignal(symbol, activePosition, exitFactors, exitScore, 'CRITICAL', currentPrice);
                } else if (exitScore >= this.exitRequirements.minExitScore) {
                    return this.createExitSignal(symbol, activePosition, exitFactors, exitScore, 'WARNING', currentPrice);
                }
                
                // Update position tracking
                this.updatePositionTracking(symbol, currentPrice, timestamp);
                
                return null; // No exit needed
            }

            // =================================================================
            // EXIT DETECTION HELPER FUNCTIONS
            // =================================================================
            detectSwingFailure(symbol, currentPrice, position) {
                const swingHigh = this.swingHighs.get(symbol);
                const swingLow = this.swingLows.get(symbol);
                
                if (position.signalType === 'BUY' && swingLow && swingLow.currentLevel) {
                    // For buy positions, check if price failed to hold above key swing low
                    if (currentPrice < swingLow.currentLevel) {
                        return { detected: true, level: swingLow.currentLevel, type: 'swing_low_break' };
                    }
                }
                
                if (position.signalType === 'SELL' && swingHigh && swingHigh.currentLevel) {
                    // For sell positions, check if price failed to hold below key swing high
                    if (currentPrice > swingHigh.currentLevel) {
                        return { detected: true, level: swingHigh.currentLevel, type: 'swing_high_break' };
                    }
                }
                
                return { detected: false };
            }
            
            detectTrendReversal(symbol, currentPrice) {
                const priceHistory = this.priceHistory.get(symbol);
                if (priceHistory.length < 10) return false;
                
                // Simple trend reversal detection based on recent price action
                const recentBars = priceHistory.slice(-10);
                const highs = recentBars.map(bar => bar.high);
                const lows = recentBars.map(bar => bar.low);
                
                // Check for lower highs in uptrend or higher lows in downtrend
                const recentHighs = highs.slice(-5);
                const recentLows = lows.slice(-5);
                
                const lowerHighs = recentHighs.every((high, index) => 
                    index === 0 || high < recentHighs[index - 1]
                );
                
                const higherLows = recentLows.every((low, index) => 
                    index === 0 || low > recentLows[index - 1]
                );
                
                return lowerHighs || higherLows;
            }
            
            detectMomentumDivergence(symbol, currentPrice, position) {
                const priceHistory = this.priceHistory.get(symbol);
                if (priceHistory.length < 20) return false;
                
                // Simplified momentum divergence detection
                const recentBars = priceHistory.slice(-20);
                const prices = recentBars.map(bar => bar.close);
                
                // Calculate simple momentum (rate of change)
                const momentum1 = prices[prices.length - 1] - prices[prices.length - 6];
                const momentum2 = prices[prices.length - 6] - prices[prices.length - 11];
                
                // Check for divergence based on position direction
                if (position.signalType === 'BUY') {
                    return momentum1 < momentum2 && momentum1 < 0; // Weakening upward momentum
                } else {
                    return momentum1 > momentum2 && momentum1 > 0; // Weakening downward momentum
                }
            }
            
            detectVolumeWeakness(symbol) {
                const priceHistory = this.priceHistory.get(symbol);
                if (priceHistory.length < 10) return false;
                
                const recentVolumes = priceHistory.slice(-5).map(bar => bar.volume);
                const previousVolumes = priceHistory.slice(-10, -5).map(bar => bar.volume);
                
                const recentAvg = recentVolumes.reduce((a, b) => a + b, 0) / recentVolumes.length;
                const previousAvg = previousVolumes.reduce((a, b) => a + b, 0) / previousVolumes.length;
                
                return recentAvg < previousAvg * 0.7; // 30% volume decline
            }
            
            checkOrderBlockBreaks(symbol, currentPrice, position) {
                const orderBlocks = this.orderBlocks.get(symbol) || [];
                
                // Check if any supporting order blocks have been broken
                return orderBlocks.some(ob => {
                    if (position.signalType === 'BUY' && ob.bias === 1) {
                        return currentPrice < ob.low; // Bullish OB broken on buy position
                    }
                    if (position.signalType === 'SELL' && ob.bias === -1) {
                        return currentPrice > ob.high; // Bearish OB broken on sell position
                    }
                    return false;
                });
            }
            
            checkFVGFills(symbol, currentPrice, position) {
                // Simplified FVG fill check
                const priceHistory = this.priceHistory.get(symbol);
                if (priceHistory.length < 5) return false;
                
                // Check if recent price action has filled gaps against the position
                const recentBars = priceHistory.slice(-5);
                const hasGapFill = recentBars.some(bar => {
                    if (position.signalType === 'BUY') {
                        return bar.low < position.entryPrice * 0.998; // 0.2% gap fill against buy
                    } else {
                        return bar.high > position.entryPrice * 1.002; // 0.2% gap fill against sell
                    }
                });
                
                return hasGapFill;
            }
            
            detectVolatilitySpike(symbol) {
                const priceHistory = this.priceHistory.get(symbol);
                if (priceHistory.length < 20) return false;
                
                const currentATR = this.calculateATR(priceHistory, 14);
                const previousATR = this.calculateATR(priceHistory.slice(0, -5), 14);
                
                return currentATR > previousATR * 1.5; // 50% volatility increase
            }
            
            checkSessionQuality(timestamp) {
                const now = new Date(timestamp);
                const hour = now.getUTCHours();
                
                // Low quality sessions (Asian session outside major news)
                const lowQuality = (hour >= 21 || hour <= 7) && 
                                  !(hour >= 23 && hour <= 2); // Exclude Asian major hours
                
                return { lowQuality, session: this.getSessionQuality() };
            }
            
            checkPartialProfitZone(currentPrice, position) {
                const entryPrice = parseFloat(position.entryPrice);
                const targetPrice = parseFloat(position.takeProfit);
                
                // Calculate if we're in 25%, 50%, or 75% profit zone
                const totalDistance = Math.abs(targetPrice - entryPrice);
                const currentDistance = Math.abs(currentPrice - entryPrice);
                const profitPercentage = (currentDistance / totalDistance) * 100;
                
                return {
                    inZone: profitPercentage >= 25,
                    percentage: profitPercentage,
                    zone: profitPercentage >= 75 ? '75%' : profitPercentage >= 50 ? '50%' : '25%'
                };
            }

            // =================================================================
            // EXIT SIGNAL CREATION
            // =================================================================
            createExitSignal(symbol, position, exitFactors, exitScore, urgency, currentPrice) {
                const exitSignal = {
                    type: 'EXIT_SIGNAL',
                    symbol,
                    urgency, // 'CRITICAL' or 'WARNING'
                    exitScore,
                    position: {
                        signalType: position.signalType,
                        entryPrice: position.entryPrice,
                        entryTime: position.entryTime,
                        currentPrice: currentPrice.toFixed(5)
                    },
                    exitFactors: this.formatExitFactors(exitFactors),
                    recommendation: this.generateExitRecommendation(urgency, exitScore, exitFactors),
                    timestamp: new Date(),
                    currentPL: this.calculateCurrentPL(position, currentPrice)
                };
                
                // Update position status
                if (urgency === 'CRITICAL') {
                    this.closePosition(symbol, 'SYSTEM_EXIT', currentPrice);
                }
                
                return exitSignal;
            }
            
            formatExitFactors(exitFactors) {
                const formattedFactors = [];
                
                exitFactors.forEach(factor => {
                    switch(factor) {
                        case 'oppositeStructureBreak':
                            formattedFactors.push('Opposite Structure Break Detected');
                            break;
                        case 'swingFailure':
                            formattedFactors.push('Key Swing Level Failed');
                            break;
                        case 'trendReversal':
                            formattedFactors.push('Trend Reversal Pattern');
                            break;
                        case 'momentumDivergence':
                            formattedFactors.push('Momentum Divergence');
                            break;
                        case 'volumeWeakness':
                            formattedFactors.push('Volume Weakness');
                            break;
                        case 'orderBlockBroken':
                            formattedFactors.push('Supporting Order Block Broken');
                            break;
                        case 'fvgFilled':
                            formattedFactors.push('Fair Value Gap Filled Against Position');
                            break;
                        case 'volatilitySpike':
                            formattedFactors.push('Unusual Volatility Spike');
                            break;
                        case 'sessionChange':
                            formattedFactors.push('Low Quality Trading Session');
                            break;
                        case 'timeBasedExit':
                            formattedFactors.push('Maximum Position Age Reached');
                            break;
                        case 'partialProfitZone':
                            formattedFactors.push('Partial Profit Zone Reached');
                            break;
                        default:
                            formattedFactors.push(factor);
                    }
                });
                
                return formattedFactors;
            }
            
            generateExitRecommendation(urgency, exitScore, exitFactors) {
                let recommendation = '';
                
                if (urgency === 'CRITICAL') {
                    recommendation = `üö® IMMEDIATE EXIT RECOMMENDED - Market conditions have changed significantly against your position. Exit Score: ${exitScore}/100. `;
                } else {
                    recommendation = `‚ö†Ô∏è CONSIDER EXIT - Market showing signs of potential reversal. Exit Score: ${exitScore}/100. `;
                }
                
                // Add specific guidance based on factors
                if (exitFactors.includes('oppositeStructureBreak')) {
                    recommendation += 'Structure has broken against your position direction. ';
                }
                
                if (exitFactors.includes('swingFailure')) {
                    recommendation += 'Key support/resistance levels have been violated. ';
                }
                
                if (exitFactors.includes('momentumDivergence')) {
                    recommendation += 'Momentum is showing signs of exhaustion. ';
                }
                
                if (urgency === 'CRITICAL') {
                    recommendation += 'Recommended action: Close position immediately.';
                } else {
                    recommendation += 'Recommended action: Monitor closely or consider partial exit.';
                }
                
                return recommendation;
            }

            // =================================================================
            // POSITION TRACKING FUNCTIONS
            // =================================================================
            trackNewPosition(symbol, signal, timestamp) {
                const position = {
                    symbol,
                    signalType: signal.signalType,
                    entryPrice: signal.entryPrice,
                    stopLoss: signal.stopLoss,
                    takeProfit: signal.takeProfit,
                    entryTime: timestamp,
                    confidence: signal.confidence,
                    confirmations: signal.confirmations,
                    status: 'ACTIVE'
                };
                
                this.activePositions.set(symbol, position);
            }
            
            updatePositionTracking(symbol, currentPrice, timestamp) {
                const position = this.activePositions.get(symbol);
                if (!position) return;
                
                position.lastUpdateTime = timestamp;
                position.currentPrice = currentPrice;
                position.currentPL = this.calculateCurrentPL(position, currentPrice);
            }
            
            closePosition(symbol, reason, exitPrice) {
                const position = this.activePositions.get(symbol);
                if (!position) return;
                
                position.status = 'CLOSED';
                position.exitPrice = exitPrice;
                position.exitReason = reason;
                position.exitTime = Date.now();
                position.finalPL = this.calculateCurrentPL(position, exitPrice);
                
                // Move to history
                if (!this.positionHistory.has(symbol)) {
                    this.positionHistory.set(symbol, []);
                }
                this.positionHistory.get(symbol).unshift(position);
                
                // Remove from active positions
                this.activePositions.delete(symbol);
            }
            
            calculateCurrentPL(position, currentPrice) {
                const entryPrice = parseFloat(position.entryPrice);
                const priceDiff = position.signalType === 'BUY' ? 
                    currentPrice - entryPrice : 
                    entryPrice - currentPrice;
                
                const plPips = priceDiff * (position.symbol.includes('JPY') ? 100 : 10000);
                return {
                    pips: parseFloat(plPips.toFixed(1)),
                    percentage: parseFloat(((priceDiff / entryPrice) * 100).toFixed(2)),
                    status: priceDiff >= 0 ? 'PROFIT' : 'LOSS'
                };
            }

            // =================================================================
            // STRUCTURE ANALYSIS - Implements your Pine Script detection logic
            // =================================================================
            performStructureAnalysis(symbol, priceHistory, currentPrice) {
                const confirmations = [];
                const currentAlerts = {
                    swingBullishBOS: false,
                    swingBearishBOS: false,
                    swingBullishCHoCH: false,
                    swingBearishCHoCH: false,
                    internalBullishBOS: false,
                    internalBearishBOS: false,
                    internalBullishCHoCH: false,
                    internalBearishCHoCH: false,
                    swingOrderBlock: false,
                    internalOrderBlock: false,
                    bullishFairValueGap: false,
                    bearishFairValueGap: false,
                    equalHighs: false,
                    equalLows: false
                };
                
                // 1. SWING STRUCTURE ANALYSIS (Your displayStructure function logic)
                const swingAnalysis = this.analyzeSwingStructure(symbol, priceHistory, currentPrice);
                Object.assign(currentAlerts, swingAnalysis.alerts);
                confirmations.push(...swingAnalysis.confirmations);
                
                // 2. INTERNAL STRUCTURE ANALYSIS 
                const internalAnalysis = this.analyzeInternalStructure(symbol, priceHistory, currentPrice);
                Object.assign(currentAlerts, internalAnalysis.alerts);
                confirmations.push(...internalAnalysis.confirmations);
                
                // 3. ORDER BLOCK ANALYSIS
                const orderBlockAnalysis = this.analyzeOrderBlocks(symbol, priceHistory, currentPrice);
                Object.assign(currentAlerts, orderBlockAnalysis.alerts);
                confirmations.push(...orderBlockAnalysis.confirmations);
                
                // 4. FAIR VALUE GAP ANALYSIS
                const fvgAnalysis = this.analyzeFairValueGaps(symbol, priceHistory, currentPrice);
                Object.assign(currentAlerts, fvgAnalysis.alerts);
                confirmations.push(...fvgAnalysis.confirmations);
                
                // 5. EQUAL HIGHS/LOWS ANALYSIS
                const eqhlAnalysis = this.analyzeEqualHighsLows(symbol, priceHistory, currentPrice);
                Object.assign(currentAlerts, eqhlAnalysis.alerts);
                confirmations.push(...eqhlAnalysis.confirmations);
                
                // 6. PREMIUM/DISCOUNT ZONE ANALYSIS
                const zoneAnalysis = this.analyzePremiumDiscountZones(symbol, priceHistory, currentPrice);
                confirmations.push(...zoneAnalysis.confirmations);
                
                // 7. ADDITIONAL CONFLUENCE FACTORS
                const additionalConfluences = this.analyzeAdditionalFactors(symbol, priceHistory, currentPrice);
                confirmations.push(...additionalConfluences.confirmations);
                
                // Determine signal direction based on your Pine Script buySignal/sellSignal logic
                let signalDirection = null;
                if (currentAlerts.swingBullishBOS || currentAlerts.swingBullishCHoCH || 
                    currentAlerts.internalBullishBOS || currentAlerts.internalBullishCHoCH) {
                    signalDirection = 'BUY';
                } else if (currentAlerts.swingBearishBOS || currentAlerts.swingBearishCHoCH || 
                           currentAlerts.internalBearishBOS || currentAlerts.internalBearishCHoCH) {
                    signalDirection = 'SELL';
                }
                
                return {
                    signalDirection,
                    confirmations,
                    alerts: currentAlerts,
                    analysis: this.generateAnalysisText(signalDirection, confirmations)
                };
            }

            // =================================================================
            // SWING STRUCTURE ANALYSIS - Your exact displayStructure logic
            // =================================================================
            analyzeSwingStructure(symbol, priceHistory, currentPrice) {
                const alerts = {};
                const confirmations = [];
                
                const swingHigh = this.swingHighs.get(symbol) || { currentLevel: null, crossed: false };
                const swingLow = this.swingLows.get(symbol) || { currentLevel: null, crossed: false };
                const swingTrend = this.swingTrend.get(symbol) || { bias: 0 }; // 0=neutral, 1=bullish, -1=bearish
                
                // Detect swing points using your leg() function logic
                const swingPoints = this.detectSwingPoints(priceHistory, 50); // swingsLengthInput = 50
                
                // Update swing levels
                if (swingPoints.newHigh) {
                    swingHigh.currentLevel = swingPoints.high;
                    swingHigh.crossed = false;
                    this.swingHighs.set(symbol, swingHigh);
                }
                if (swingPoints.newLow) {
                    swingLow.currentLevel = swingPoints.low;
                    swingLow.crossed = false;
                    this.swingLows.set(symbol, swingLow);
                }
                
                // Check for bullish structure break (ta.crossover logic)
                if (swingHigh.currentLevel && currentPrice > swingHigh.currentLevel && !swingHigh.crossed) {
                    const tag = swingTrend.bias === -1 ? 'CHoCH' : 'BOS'; // BEARISH to BULLISH = CHoCH
                    
                    alerts.swingBullishBOS = tag === 'BOS';
                    alerts.swingBullishCHoCH = tag === 'CHoCH';
                    
                    if (tag === 'BOS') confirmations.push('swingBullishBOS');
                    if (tag === 'CHoCH') confirmations.push('swingBullishCHoCH');
                    
                    swingHigh.crossed = true;
                    swingTrend.bias = 1; // BULLISH
                    this.swingTrend.set(symbol, swingTrend);
                }
                
                // Check for bearish structure break (ta.crossunder logic)
                if (swingLow.currentLevel && currentPrice < swingLow.currentLevel && !swingLow.crossed) {
                    const tag = swingTrend.bias === 1 ? 'CHoCH' : 'BOS'; // BULLISH to BEARISH = CHoCH
                    
                    alerts.swingBearishBOS = tag === 'BOS';
                    alerts.swingBearishCHoCH = tag === 'CHoCH';
                    
                    if (tag === 'BOS') confirmations.push('swingBearishBOS');
                    if (tag === 'CHoCH') confirmations.push('swingBearishCHoCH');
                    
                    swingLow.crossed = true;
                    swingTrend.bias = -1; // BEARISH
                    this.swingTrend.set(symbol, swingTrend);
                }
                
                return { alerts, confirmations };
            }

            // =================================================================
            // INTERNAL STRUCTURE ANALYSIS - 5-period structure
            // =================================================================
            analyzeInternalStructure(symbol, priceHistory, currentPrice) {
                const alerts = {};
                const confirmations = [];
                
                const internalHigh = this.internalHighs.get(symbol) || { currentLevel: null, crossed: false };
                const internalLow = this.internalLows.get(symbol) || { currentLevel: null, crossed: false };
                const internalTrend = this.internalTrend.get(symbol) || { bias: 0 };
                
                // Detect internal swing points (5-period lookback)
                const internalSwings = this.detectSwingPoints(priceHistory, 5);
                
                // Update internal levels
                if (internalSwings.newHigh) {
                    internalHigh.currentLevel = internalSwings.high;
                    internalHigh.crossed = false;
                    this.internalHighs.set(symbol, internalHigh);
                }
                if (internalSwings.newLow) {
                    internalLow.currentLevel = internalSwings.low;
                    internalLow.crossed = false;
                    this.internalLows.set(symbol, internalLow);
                }
                
                // Internal bullish structure break
                if (internalHigh.currentLevel && currentPrice > internalHigh.currentLevel && !internalHigh.crossed) {
                    const tag = internalTrend.bias === -1 ? 'CHoCH' : 'BOS';
                    
                    alerts.internalBullishBOS = tag === 'BOS';
                    alerts.internalBullishCHoCH = tag === 'CHoCH';
                    
                    if (tag === 'BOS') confirmations.push('internalBullishBOS');
                    if (tag === 'CHoCH') confirmations.push('internalBullishCHoCH');
                    
                    internalHigh.crossed = true;
                    internalTrend.bias = 1;
                    this.internalTrend.set(symbol, internalTrend);
                }
                
                // Internal bearish structure break
                if (internalLow.currentLevel && currentPrice < internalLow.currentLevel && !internalLow.crossed) {
                    const tag = internalTrend.bias === 1 ? 'CHoCH' : 'BOS';
                    
                    alerts.internalBearishBOS = tag === 'BOS';
                    alerts.internalBearishCHoCH = tag === 'CHoCH';
                    
                    if (tag === 'BOS') confirmations.push('internalBearishBOS');
                    if (tag === 'CHoCH') confirmations.push('internalBearishCHoCH');
                    
                    internalLow.crossed = true;
                    internalTrend.bias = -1;
                    this.internalTrend.set(symbol, internalTrend);
                }
                
                return { alerts, confirmations };
            }

            // =================================================================
            // ORDER BLOCK ANALYSIS - Your storeOrderBlock logic
            // =================================================================
            analyzeOrderBlocks(symbol, priceHistory, currentPrice) {
                const alerts = {};
                const confirmations = [];
                
                if (priceHistory.length < 10) return { alerts, confirmations };
                
                // Get stored order blocks for this symbol
                let orderBlocks = this.orderBlocks.get(symbol) || [];
                
                // Check for order block mitigation/respect
                const atr = this.calculateATR(priceHistory, 14);
                
                orderBlocks.forEach(orderBlock => {
                    const inOrderBlockZone = currentPrice >= orderBlock.low && currentPrice <= orderBlock.high;
                    
                    if (inOrderBlockZone) {
                        if (orderBlock.bias === 1) { // Bullish order block
                            confirmations.push('swingOrderBlockRespect');
                            alerts.swingOrderBlock = true;
                        } else if (orderBlock.bias === -1) { // Bearish order block
                            confirmations.push('swingOrderBlockRespect');
                            alerts.swingOrderBlock = true;
                        }
                    }
                });
                
                // Create new order blocks when structure breaks (simplified logic)
                const recentBars = priceHistory.slice(-5);
                const hasOrderBlockFormation = this.detectOrderBlockFormation(recentBars);
                
                if (hasOrderBlockFormation.bullish) {
                    const newOB = {
                        high: hasOrderBlockFormation.high,
                        low: hasOrderBlockFormation.low,
                        bias: 1,
                        timestamp: Date.now()
                    };
                    orderBlocks.unshift(newOB);
                    confirmations.push('internalOrderBlockRespect');
                }
                
                if (hasOrderBlockFormation.bearish) {
                    const newOB = {
                        high: hasOrderBlockFormation.high,
                        low: hasOrderBlockFormation.low,
                        bias: -1,
                        timestamp: Date.now()
                    };
                    orderBlocks.unshift(newOB);
                    confirmations.push('internalOrderBlockRespect');
                }
                
                // Keep only recent order blocks (max 10)
                if (orderBlocks.length > 10) {
                    orderBlocks = orderBlocks.slice(0, 10);
                }
                
                this.orderBlocks.set(symbol, orderBlocks);
                
                return { alerts, confirmations };
            }

            // =================================================================
            // FAIR VALUE GAP ANALYSIS - Your drawFairValueGaps logic
            // =================================================================
            analyzeFairValueGaps(symbol, priceHistory, currentPrice) {
                const alerts = {};
                const confirmations = [];
                
                if (priceHistory.length < 5) return { alerts, confirmations };
                
                const recentBars = priceHistory.slice(-5);
                
                // Detect bullish FVG: gap between bar[2].high and current.low
                for (let i = 2; i < recentBars.length; i++) {
                    const prev2 = recentBars[i - 2];
                    const current = recentBars[i];
                    
                    // Bullish FVG
                    if (prev2.high < current.low) {
                        confirmations.push('bullishFairValueGap');
                        alerts.bullishFairValueGap = true;
                    }
                    
                    // Bearish FVG
                    if (prev2.low > current.high) {
                        confirmations.push('bearishFairValueGap');
                        alerts.bearishFairValueGap = true;
                    }
                }
                
                return { alerts, confirmations };
            }

            // =================================================================
            // EQUAL HIGHS/LOWS ANALYSIS - Your drawEqualHighLow logic
            // =================================================================
            analyzeEqualHighsLows(symbol, priceHistory, currentPrice) {
                const alerts = {};
                const confirmations = [];
                
                if (priceHistory.length < 10) return { alerts, confirmations };
                
                const atr = this.calculateATR(priceHistory, 14);
                const threshold = 0.1 * atr; // equalHighsLowsThresholdInput = 0.1
                
                // Get recent highs and lows
                const recentBars = priceHistory.slice(-10);
                const highs = recentBars.map(bar => bar.high);
                const lows = recentBars.map(bar => bar.low);
                
                // Check for equal highs
                const equalHighLevels = this.findEqualLevels(highs, threshold);
                if (equalHighLevels.length >= 2 && currentPrice > Math.max(...equalHighLevels)) {
                    confirmations.push('equalHighsBreak');
                    alerts.equalHighs = true;
                }
                
                // Check for equal lows
                const equalLowLevels = this.findEqualLevels(lows, threshold);
                if (equalLowLevels.length >= 2 && currentPrice < Math.min(...equalLowLevels)) {
                    confirmations.push('equalLowsBreak');
                    alerts.equalLows = true;
                }
                
                return { alerts, confirmations };
            }

            // =================================================================
            // PREMIUM/DISCOUNT ZONE ANALYSIS
            // =================================================================
            analyzePremiumDiscountZones(symbol, priceHistory, currentPrice) {
                const confirmations = [];
                
                if (priceHistory.length < 20) return { confirmations };
                
                // Get recent swing high and low
                const recentBars = priceHistory.slice(-20);
                const swingHigh = Math.max(...recentBars.map(bar => bar.high));
                const swingLow = Math.min(...recentBars.map(bar => bar.low));
                
                const range = swingHigh - swingLow;
                const currentLevel = (currentPrice - swingLow) / range;
                
                // Premium zone (70% and above)
                if (currentLevel >= 0.7) {
                    confirmations.push('premiumZoneEntry');
                }
                // Discount zone (30% and below)
                else if (currentLevel <= 0.3) {
                    confirmations.push('discountZoneEntry');
                }
                // Equilibrium zone (40-60%)
                else if (currentLevel >= 0.4 && currentLevel <= 0.6) {
                    confirmations.push('equilibriumZone');
                }
                
                return { confirmations };
            }

            // =================================================================
            // ADDITIONAL CONFLUENCE FACTORS
            // =================================================================
            analyzeAdditionalFactors(symbol, priceHistory, currentPrice) {
                const confirmations = [];
                
                // Volume confirmation (simplified)
                if (priceHistory.length >= 10) {
                    const avgVolume = priceHistory.slice(-10).reduce((sum, bar) => sum + bar.volume, 0) / 10;
                    const currentVolume = priceHistory[priceHistory.length - 1].volume;
                    
                    if (currentVolume > avgVolume * 1.3) {
                        confirmations.push('volumeConfirmation');
                    }
                }
                
                // ATR volatility filter
                if (priceHistory.length >= 14) {
                    const atr = this.calculateATR(priceHistory, 14);
                    const currentRange = priceHistory[priceHistory.length - 1].high - priceHistory[priceHistory.length - 1].low;
                    
                    if (currentRange > atr * 1.2) {
                        confirmations.push('atrVolatilityFilter');
                    }
                }
                
                return { confirmations };
            }

            // =================================================================
            // CONFIDENCE CALCULATION - Dynamic scoring system
            // =================================================================
            calculateConfidence(confirmations) {
                let totalScore = 0;
                let primaryConfirmations = 0;
                
                confirmations.forEach(confirmation => {
                    if (this.confirmationScores[confirmation]) {
                        totalScore += this.confirmationScores[confirmation];
                        
                        // Count primary structure confirmations
                        if (confirmation.includes('BOS') || confirmation.includes('CHoCH')) {
                            primaryConfirmations++;
                        }
                    }
                });
                
                // Bonus for multiple primary confirmations
                if (primaryConfirmations >= 2) {
                    totalScore += 10;
                }
                
                // Penalty for insufficient confirmations
                if (confirmations.length < 4) {
                    totalScore *= 0.8;
                }
                
                return Math.min(Math.round(totalScore), 100);
            }

            // =================================================================
            // TRADING LEVELS CALCULATION - Your createTradingLevel logic
            // =================================================================
            calculateTradingLevels(symbol, signalDirection, currentPrice, priceHistory) {
                const atr = this.calculateATR(priceHistory, 14);
                const riskRewardRatio = window.riskRewardRatio || 2.0;
                
                let entryPrice = currentPrice;
                let stopLoss, takeProfit;
                
                if (signalDirection === 'BUY') {
                    // For bullish signals - SL below recent low
                    const recentLows = priceHistory.slice(-10).map(bar => bar.low);
                    const recentLow = Math.min(...recentLows);
                    stopLoss = Math.min(recentLow - (atr * 0.5), currentPrice - (atr * 1.5));
                    
                    const riskDistance = entryPrice - stopLoss;
                    takeProfit = entryPrice + (riskDistance * riskRewardRatio);
                } else {
                    // For bearish signals - SL above recent high
                    const recentHighs = priceHistory.slice(-10).map(bar => bar.high);
                    const recentHigh = Math.max(...recentHighs);
                    stopLoss = Math.max(recentHigh + (atr * 0.5), currentPrice + (atr * 1.5));
                    
                    const riskDistance = stopLoss - entryPrice;
                    takeProfit = entryPrice - (riskDistance * riskRewardRatio);
                }
                
                return {
                    entryPrice: parseFloat(entryPrice.toFixed(5)),
                    stopLoss: parseFloat(stopLoss.toFixed(5)),
                    takeProfit: parseFloat(takeProfit.toFixed(5)),
                    riskReward: `1:${riskRewardRatio}`
                };
            }

            // =================================================================
            // SIGNAL VALIDATION - Quality control
            // =================================================================
            validateSignalQuality(analysis) {
                if (!analysis.signalDirection) return false;
                
                const primaryCount = analysis.confirmations.filter(c => 
                    c.includes('BOS') || c.includes('CHoCH')
                ).length;
                
                const confidence = this.calculateConfidence(analysis.confirmations);
                
                return (
                    primaryCount >= this.signalRequirements.minPrimaryConfirmations &&
                    analysis.confirmations.length >= this.signalRequirements.minTotalConfirmations &&
                    confidence >= this.signalRequirements.minConfidenceScore
                );
            }

            // =================================================================
            // HELPER FUNCTIONS
            // =================================================================
            initializeSymbolData(symbol, currentPrice, timestamp) {
                if (!this.priceHistory.has(symbol)) {
                    this.priceHistory.set(symbol, []);
                }
                
                // Create realistic OHLC bar
                const volatility = this.getSymbolVolatility(symbol);
                const high = currentPrice + (Math.random() * volatility * currentPrice);
                const low = currentPrice - (Math.random() * volatility * currentPrice);
                const open = low + (Math.random() * (high - low));
                
                const newBar = {
                    timestamp,
                    open: parseFloat(open.toFixed(5)),
                    high: parseFloat(high.toFixed(5)),
                    low: parseFloat(low.toFixed(5)),
                    close: currentPrice,
                    volume: Math.random() * 1000000 + 500000
                };
                
                const history = this.priceHistory.get(symbol);
                history.push(newBar);
                
                // Keep last 100 bars
                if (history.length > 100) {
                    history.splice(0, history.length - 100);
                }
            }

            detectSwingPoints(priceHistory, lookback) {
                if (priceHistory.length < lookback * 2 + 1) {
                    return { newHigh: false, newLow: false, high: null, low: null };
                }
                
                const currentIndex = priceHistory.length - lookback - 1;
                const currentBar = priceHistory[currentIndex];
                
                let isSwingHigh = true;
                let isSwingLow = true;
                
                // Check if current bar is highest/lowest in lookback period
                for (let i = currentIndex - lookback; i <= currentIndex + lookback; i++) {
                    if (i !== currentIndex && i >= 0 && i < priceHistory.length) {
                        if (priceHistory[i].high >= currentBar.high) isSwingHigh = false;
                        if (priceHistory[i].low <= currentBar.low) isSwingLow = false;
                    }
                }
                
                return {
                    newHigh: isSwingHigh,
                    newLow: isSwingLow,
                    high: isSwingHigh ? currentBar.high : null,
                    low: isSwingLow ? currentBar.low : null
                };
            }

            calculateATR(priceHistory, period) {
                if (priceHistory.length < period + 1) {
                    return priceHistory.length > 0 ? priceHistory[0].close * 0.001 : 0.01; // Default ATR
                }
                
                const trueRanges = [];
                for (let i = 1; i < priceHistory.length; i++) {
                    const current = priceHistory[i];
                    const previous = priceHistory[i - 1];
                    
                    const tr = Math.max(
                        current.high - current.low,
                        Math.abs(current.high - previous.close),
                        Math.abs(current.low - previous.close)
                    );
                    trueRanges.push(tr);
                }
                
                const recentTRs = trueRanges.slice(-period);
                return recentTRs.reduce((sum, tr) => sum + tr, 0) / recentTRs.length;
            }

            detectOrderBlockFormation(recentBars) {
                // Simplified order block detection
                if (recentBars.length < 3) return { bullish: false, bearish: false };
                
                const prev = recentBars[recentBars.length - 3];
                const current = recentBars[recentBars.length - 2];
                const next = recentBars[recentBars.length - 1];
                
                // Bullish order block: down candle followed by strong up move
                const bullishOB = (prev.close < prev.open) && 
                                 (next.close > current.high) && 
                                 ((next.high - next.low) > (current.high - current.low) * 1.5);
                
                // Bearish order block: up candle followed by strong down move
                const bearishOB = (prev.close > prev.open) && 
                                 (next.close < current.low) && 
                                 ((next.high - next.low) > (current.high - current.low) * 1.5);
                
                return {
                    bullish: bullishOB,
                    bearish: bearishOB,
                    high: current.high,
                    low: current.low
                };
            }

            findEqualLevels(levels, threshold) {
                const equalLevels = [];
                
                for (let i = 0; i < levels.length; i++) {
                    for (let j = i + 1; j < levels.length; j++) {
                        if (Math.abs(levels[i] - levels[j]) <= threshold) {
                            if (!equalLevels.includes(levels[i])) equalLevels.push(levels[i]);
                            if (!equalLevels.includes(levels[j])) equalLevels.push(levels[j]);
                        }
                    }
                }
                
                return equalLevels;
            }

            canGenerateSignal(symbol, timestamp) {
                const lastSignal = this.lastSignalTime.get(symbol);
                return !lastSignal || (timestamp - lastSignal) >= this.signalRequirements.cooldownPeriod;
            }

            getSymbolVolatility(symbol) {
                const volatilityMap = {
                    'EUR/USD': 0.0008, 'GBP/USD': 0.0012, 'USD/JPY': 0.008,
                    'XAU/USD': 0.002, 'XAG/USD': 0.003, 'BTC/USD': 0.02,
                    'ETH/USD': 0.025, 'USOIL': 0.015
                };
                return volatilityMap[symbol] || 0.001;
            }

            createTradingSignal(symbol, analysis, currentPrice) {
                const confidence = this.calculateConfidence(analysis.confirmations);
                const priceHistory = this.priceHistory.get(symbol);
                const tradingLevels = this.calculateTradingLevels(symbol, analysis.signalDirection, currentPrice, priceHistory);
                
                return {
                    symbol,
                    signalType: analysis.signalDirection,
                    confidence,
                    entryPrice: tradingLevels.entryPrice,
                    stopLoss: tradingLevels.stopLoss,
                    takeProfit: tradingLevels.takeProfit,
                    riskReward: tradingLevels.riskReward,
                    confirmations: this.formatConfirmations(analysis.confirmations),
                    timestamp: new Date(),
                    analysis: analysis.analysis,
                    sessionQuality: this.getSessionQuality(),
                    timeframe: '15m' // Default timeframe
                };
            }

            formatConfirmations(confirmations) {
                const formattedConfirmations = [];
                
                confirmations.forEach(confirmation => {
                    switch(confirmation) {
                        case 'swingBullishBOS':
                            formattedConfirmations.push('Swing Bullish BOS');
                            break;
                        case 'swingBearishBOS':
                            formattedConfirmations.push('Swing Bearish BOS');
                            break;
                        case 'swingBullishCHoCH':
                            formattedConfirmations.push('Swing Bullish CHoCH');
                            break;
                        case 'swingBearishCHoCH':
                            formattedConfirmations.push('Swing Bearish CHoCH');
                            break;
                        case 'internalBullishBOS':
                            formattedConfirmations.push('Internal Bullish BOS');
                            break;
                        case 'internalBearishBOS':
                            formattedConfirmations.push('Internal Bearish BOS');
                            break;
                        case 'internalBullishCHoCH':
                            formattedConfirmations.push('Internal Bullish CHoCH');
                            break;
                        case 'internalBearishCHoCH':
                            formattedConfirmations.push('Internal Bearish CHoCH');
                            break;
                        case 'swingOrderBlockRespect':
                            formattedConfirmations.push('Swing Order Block Respect');
                            break;
                        case 'internalOrderBlockRespect':
                            formattedConfirmations.push('Internal Order Block Respect');
                            break;
                        case 'bullishFairValueGap':
                            formattedConfirmations.push('Bullish Fair Value Gap');
                            break;
                        case 'bearishFairValueGap':
                            formattedConfirmations.push('Bearish Fair Value Gap');
                            break;
                        case 'equalHighsBreak':
                            formattedConfirmations.push('Equal Highs Break');
                            break;
                        case 'equalLowsBreak':
                            formattedConfirmations.push('Equal Lows Break');
                            break;
                        case 'premiumZoneEntry':
                            formattedConfirmations.push('Premium Zone Entry');
                            break;
                        case 'discountZoneEntry':
                            formattedConfirmations.push('Discount Zone Entry');
                            break;
                        case 'equilibriumZone':
                            formattedConfirmations.push('Equilibrium Zone');
                            break;
                        case 'volumeConfirmation':
                            formattedConfirmations.push('Volume Confirmation');
                            break;
                        case 'atrVolatilityFilter':
                            formattedConfirmations.push('ATR Volatility Filter');
                            break;
                        default:
                            formattedConfirmations.push(confirmation);
                    }
                });
                
                return formattedConfirmations;
            }

            generateAnalysisText(signalDirection, confirmations) {
                if (!signalDirection) return 'No clear directional bias detected.';
                
                const direction = signalDirection === 'BUY' ? 'bullish' : 'bearish';
                const confidence = this.calculateConfidence(confirmations);
                
                let analysis = `${confidence >= 80 ? 'Very Strong' : confidence >= 70 ? 'Strong' : 'Moderate'} ${direction} setup detected. `;
                
                // Structure analysis
                const hasSwingBOS = confirmations.some(c => c.includes('swingBullishBOS') || c.includes('swingBearishBOS'));
                const hasSwingCHoCH = confirmations.some(c => c.includes('swingBullishCHoCH') || c.includes('swingBearishCHoCH'));
                const hasInternalBOS = confirmations.some(c => c.includes('internalBullishBOS') || c.includes('internalBearishBOS'));
                
                if (hasSwingBOS) {
                    analysis += `Major swing Break of Structure confirms ${direction} momentum shift. `;
                }
                if (hasSwingCHoCH) {
                    analysis += `Swing Change of Character indicates potential trend reversal. `;
                }
                if (hasInternalBOS) {
                    analysis += `Internal structure break provides additional confluence. `;
                }
                
                // Order block analysis
                if (confirmations.some(c => c.includes('OrderBlock'))) {
                    analysis += `Price respecting institutional order block levels. `;
                }
                
                // Fair Value Gap analysis
                if (confirmations.some(c => c.includes('FairValueGap'))) {
                    analysis += `Fair Value Gap providing strong directional bias. `;
                }
                
                // Zone analysis
                if (confirmations.includes('premiumZoneEntry')) {
                    analysis += `Entry from premium zone - ideal for ${direction === 'bearish' ? 'sell' : 'buy'} setups. `;
                }
                if (confirmations.includes('discountZoneEntry')) {
                    analysis += `Entry from discount zone - optimal for ${direction === 'bullish' ? 'buy' : 'sell'} entries. `;
                }
                
                // Risk assessment
                if (confidence >= 80) {
                    analysis += `High-probability setup suitable for standard position sizing.`;
                } else if (confidence >= 70) {
                    analysis += `Good probability setup - consider normal position size.`;
                } else if (confidence >= 60) {
                    analysis += `Moderate probability - use reduced position size and tight risk management.`;
                }
                
                return analysis;
            }

            getSessionQuality() {
                const now = new Date();
                const hour = now.getUTCHours();
                
                // London session (7-16 UTC) - High quality
                if (hour >= 7 && hour <= 16) return 'London Session - High';
                // New York session (12-21 UTC) - High quality  
                if (hour >= 12 && hour <= 21) return 'New York Session - High';
                // London/NY overlap (12-16 UTC) - Very High quality
                if (hour >= 12 && hour <= 16) return 'London/NY Overlap - Very High';
                // Asian session (21-7 UTC) - Medium quality
                return 'Asian Session - Medium';
            }
        }

        // --- Data Fetching ---
        async function fetchBinanceData(symbol, interval, limit = 200) {
            const intervalMap = { '1m': '1m', '3m': '3m', '5m': '5m', '15m': '15m', '30m': '30m', '1h': '1h', '4h': '4h', '1d': '1d' };
            const binanceInterval = intervalMap[interval];
            if (!binanceInterval) {
                log(`Unsupported timeframe for Binance: ${interval}`, 'error');
                return null;
            }
            
            const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${binanceInterval}&limit=${limit}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Binance API error ${response.status}: ${errorData.msg || 'Unknown error'}`);
                }
                const data = await response.json();
                const mappedData = data.map(d => ({
                    time: d[0] / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                }));
                if (mappedData.length > 0) {
                    lastData[symbol] = mappedData[mappedData.length - 1].close;
                }
                return mappedData;
            } catch (error) {
                log(`Error fetching Binance data for ${symbol}: ${error.message}`, 'error');
                return null;
            }
        }

        async function fetchCryptoData(symbol, interval, limit = 200) {
            return fetchBinanceData(symbol, interval, limit);
        }

        async function fetchForexData(symbol, interval, limit = 200) {
            log(`Forex data fetching is not configured. Please switch to Crypto market.`, 'error');
            return null;
        }

        // --- UI & Logging ---
        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
            logsContainer.appendChild(entry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }

        function updateStatus(running) {
            botRunning = running;
            statusDot.classList.toggle('active', running);
            statusText.textContent = running ? 'Bot is Running' : 'Ready to Connect';
            systemStatusEl.textContent = running ? 'Running' : 'Ready';
            startBtn.disabled = running;
            stopBtn.disabled = !running;
            [symbolSelect, timeframeSelect, riskRewardInput, ...marketBtns].forEach(el => el.disabled = running);
        }

        function populateSymbols() {
            symbolSelect.innerHTML = '<option value="">Select Symbol</option><option value="ALL" class="select-all-option">üìä ALL SYMBOLS</option>';
            markets[currentMarket].symbols.forEach(s => {
                const option = document.createElement('option');
                option.value = s;
                option.textContent = s;
                symbolSelect.appendChild(option);
            });
        }

        function updateMarketData() {
            const uniqueSymbols = new Set(activeConnections.map(c => c.symbol));
            const uniqueTimeframes = new Set(activeConnections.map(c => c.timeframe));
            activePairsEl.textContent = uniqueSymbols.size;
            activeTimeframesEl.textContent = uniqueTimeframes.size;
            const today = new Date().toISOString().slice(0, 10);
            signalsTodayEl.textContent = signalHistory.filter(s => s.timestamp.startsWith(today)).length;
            const wins = signalHistory.filter(s => s.status.startsWith('target_hit')).length;
            const losses = signalHistory.filter(s => s.status === 'sl_hit').length;
            winRateEl.textContent = (wins + losses > 0) ? `Win Rate: ${((wins / (wins + losses)) * 100).toFixed(1)}%` : 'Win Rate: --%';
        }

        // --- Core Bot Logic ---
        function switchMarket(market) {
            if (botRunning) return;
            currentMarket = market;
            marketBtns.forEach(btn => btn.classList.toggle('active', btn.textContent.toLowerCase().includes(market)));
            populateSymbols();
            log(`Switched to ${market.toUpperCase()} market.`);
        }

        function startBot() {
            const symbols = symbolSelect.value === 'ALL' ? markets[currentMarket].symbols : [symbolSelect.value];
            const timeframes = timeframeSelect.value === 'ALL' ? Array.from(timeframeSelect.options).slice(2).map(o => o.value) : [timeframeSelect.value];
            if (!symbols[0] || !timeframes[0]) { return log('Please select a symbol and timeframe.', 'error'); }
            const riskRewardRatio = parseFloat(riskRewardInput.value);
            if (isNaN(riskRewardRatio) || riskRewardRatio < 1) { return log('Please enter a valid Risk:Reward Ratio >= 1.0', 'error'); }
            window.riskRewardRatio = riskRewardRatio;
            updateStatus(true);
            log(`Starting bot for ${currentMarket.toUpperCase()}...`, 'success');
            signalsContainer.innerHTML = '';

            let delay = 0;
            symbols.forEach(symbol => {
                timeframes.forEach(timeframe => {
                    setTimeout(() => {
                        startAnalysis(symbol, timeframe);
                    }, delay);
                    delay += 200; // 200ms delay between starting each analysis
                });
            });
            
            activeConnections.push({ symbol: 'MONITOR', timeframe: '1s', intervalId: setInterval(monitorActiveSignals, 1000) });
        }

        function stopBot() {
            log('Stopping bot...', 'error');
            activeConnections.forEach(conn => clearInterval(conn.intervalId));
            activeConnections = [];
            updateStatus(false);
            updateMarketData();
        }

        function refreshSystem() {
            if (botRunning) stopBot();
            log('System refreshed. Ready for new configuration.');
            signalHistory = [];
            signalsContainer.innerHTML = '<div class="no-signals"><p>Configure settings and start the bot to receive real-time signals</p></div>';
            updateMarketData();
        }

        async function startAnalysis(symbol, timeframe) {
            log(`Initializing analysis for ${symbol} (${timeframe})...`);
            const fetchData = currentMarket === 'crypto' ? fetchCryptoData : fetchForexData;

            // Pre-load historical data to prevent "insufficient history" errors
            const initialData = await fetchData(symbol, timeframe, 200);
            if (!initialData || initialData.length < smcEngine.signalRequirements.minHistoryBars) {
                log(`Failed to fetch sufficient initial data for ${symbol} (${timeframe}). Analysis stopped.`, 'error');
                return;
            }

            // Populate the engine's history
            const history = smcEngine.priceHistory.get(symbol) || [];
            initialData.forEach(bar => {
                history.push({
                    timestamp: bar.time * 1000,
                    open: bar.open,
                    high: bar.high,
                    low: bar.low,
                    close: bar.close,
                    volume: bar.volume
                });
            });
            smcEngine.priceHistory.set(symbol, history);
            
            const analyze = async () => {
                const data = await fetchData(symbol, timeframe, 1); // Fetch only the latest candle
                if (data && data.length > 0) {
                    const lastPrice = data[data.length - 1].close;
                    const priceData = { price: lastPrice };
                    
                    const result = await performAdvancedSMCAnalysis(symbol, priceData, timeframe);
                    
                    if (result && result.signalType) { // It's an entry signal
                        if (!signalHistory.find(s => s.id === result.id)) {
                            result.status = 'active';
                            result.direction = result.signalType === 'BUY' ? 'bullish' : 'bearish';
                            signalHistory.push(result);
                        }
                    } else if (result && result.type === 'EXIT_SIGNAL') { // It's an exit signal
                        // Exit signal is displayed by its own function
                    }

                    lastUpdateEl.textContent = `Last Update: ${new Date().toLocaleTimeString()}`;
                    updateMarketData();
                }
            };

            await analyze(); // Initial analysis
            const intervalId = setInterval(analyze, 60000); // Analyze every minute
            activeConnections.push({ symbol, timeframe, intervalId });
            updateMarketData();
        }

        function displaySignal(signal) {
            if (document.querySelector('.no-signals')) { signalsContainer.innerHTML = ''; }
            const card = document.createElement('div');
            card.className = `signal-card ${signal.direction}`;
            card.id = signal.id;
            card.innerHTML = `
                <div class="signal-header">
                    <div class="signal-type ${signal.direction}">${signal.symbol} - ${signal.timeframe.toUpperCase()} ${signal.direction.toUpperCase()}</div>
                    <div class="confidence">${signal.confidence}% Confidence</div>
                </div>
                <div class="signal-details">
                    <div class="detail-item"><div class="detail-label">Entry</div><div class="detail-value">${signal.entry}</div></div>
                    <div class="detail-item"><div class="detail-label">Stop Loss</div><div class="detail-value">${signal.stopLoss}</div></div>
                    <div class="detail-item"><div class="detail-label">Take Profit</div><div class="detail-value">${signal.takeProfit}</div></div>
                    <div class="detail-item"><div class="detail-label">Structure</div><div class="detail-value">${signal.type} (${signal.structureLevel})</div></div>
                </div>
                <div class="analysis">${signal.analysis}</div>
                <div class="signal-status">Active</div>`;
            signalsContainer.prepend(card);
            log(`New ${signal.direction} signal for ${signal.symbol} on ${signal.timeframe}.`, 'success');
        }
        
        function monitorActiveSignals() {
            const activeSignals = signalHistory.filter(s => s.status === 'active');
            activeSignals.forEach(signal => {
                const currentPrice = lastData[signal.symbol];
                if (!currentPrice) return;
                if (signal.direction === 'bullish' && currentPrice <= signal.stopLoss) { signal.status = 'sl_hit'; updateSignalCard(signal); }
                else if (signal.direction === 'bearish' && currentPrice >= signal.stopLoss) { signal.status = 'sl_hit'; updateSignalCard(signal); }
                else if (signal.direction === 'bullish' && currentPrice >= signal.takeProfit) { signal.status = 'target_hit'; updateSignalCard(signal); }
                else if (signal.direction === 'bearish' && currentPrice <= signal.takeProfit) { signal.status = 'target_hit'; updateSignalCard(signal); }
            });
        }

        function updateSignalCard(signal) {
            const card = document.getElementById(signal.id);
            if (!card) return;
            if (signal.status === 'sl_hit') {
                card.classList.add('sl_hit');
                card.querySelector('.signal-status').textContent = 'SL Hit';
                log(`${signal.symbol} SL hit.`, 'error');
                updateMarketData();
            } else if (signal.status === 'target_hit') {
                card.classList.add('target_hit');
                card.querySelector('.signal-status').textContent = 'TP Hit';
                log(`${signal.symbol} TP hit!`, 'success');
                updateMarketData();
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            populateSymbols();
            log('SMC Pro Elite Bot initialized - Configure settings to start.');
        });
    </script>
</body>
</html>

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.

<environment_details>
# VSCode Visible Files
index.html

# VSCode Open Tabs
index.html

# Recently Modified Files
These files have been modified since you last accessed them (file was just edited so you may need to re-read it before editing):
index.html

# Current Time
8/3/2025, 5:04:01 PM (Asia/Calcutta, UTC+5.5:00)

# Context Window Usage
193,210 / 1,048.576K tokens used (18%)

# Current Mode
ACT MODE
</environment_details>
